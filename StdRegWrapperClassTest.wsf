<package>
<job id="StdRegWrapperClassTest">
<script language="JScript">//<!-- GlobalCode LeadingTag -->
'use strict';
//---------------------------------------------------------------------
// © Oleg Kulikov, sysprg@live.ru
//---------------------------------------------------------------------
// Project: StdRegWrapperClassTest
// Version: 1.0
// FileId:  f:\Delme\CleanBCD\StdRegWrapperClass.wsf
// When:    15 Aug 2015,  Friday,  13:19:00
// Who:     Oleg Kulikov, sysprg@live.ru
//---------------------------------------------------------------------
// This head was generated by PROFILE.THE code of the THE.EXE
//---------------------------------------------------------------------
// History of the project code:
// August 15, no one Set/Delete metothod is not yet implemented.  
// List of methods at August 15:
// This class exports wrapper class methods for likewise StdRegProv methods:       //                                                             //                                                             //
// RegEnumSubKey(    root, regPath )                                               //
// RegEnumValues(    root, regPath )                                               //
// RegCheckAccess(   root, regPath )                                               //
// RegGetDWORDValue(          root, regPath, valueName )                           //
// RegGetQWORDValue(          root, regPath, valueName )                           //
// RegGetBinaryValue(         root, regPath, valueName )                           //
// RegGetStringValue(         root, regPath, valueName )                           //
// RegGetMultiStringValue(    root, regPath, valueName )                           //
// RegGetExpandedStringValue( root, regPath, valueName )                           //
//---------------------------------------------------------------------------------//

// June 23, implemented in all of the code.
function GlobalBuffers()
{
   var IMess = [];
   var EMess = [];

   this.Out = {};
   this.Out.StdErr = WScript.StdErr;
   this.Out.StdOut = WScript.StdOut;

   this.PutIMsg = function( msg )
   {
      IMess[ IMess.length ] = msg;
      return false;
   }
   this.PutEMsg = function( msg )
   {
      PMess[ EMess.length ] = msg;
      return false;
   }
   this.UnloadBuffers = function( )
   {
      for ( var i = 0; i < EMess.length; i++ )
      {
         this.Out.StdErr.WriteLine( EMess[ i ] );
      }
      EMess = [];
      for ( var i = 0; i < IMess.length; i++ )
      {
         this.Out.StdOut.WriteLine( IMess[ i ] );
      }
      PMess = [];
   }
}

String.prototype.startsWith = function( str )
{
   return ( this.substr( 0, str.length ).toLowerCase() == str.toLowerCase() );
}

var CurrentUserSID       = '';
var CurrentUserObject    = {}; // June 26
var CurrentVersionObject = {}; // June 26

// GetCurrentUserSID function
// Is called from StdRegWrapperClass constructor
// Returns SID for the last logged user
// Final fix: June 25, June 26 - eliminated,
// replaced by the code at the bottom of this
// class code which builds objects

</script>                    <!-- GlobalCode         TraingTag  -->
<script language="JScript">//<!-- StdRegWrapperClass LeadingTag -->
'use strict';
/////////////////////////////////////////////////////////////////////////////////////
//                    StdRegWrapperClass( ServerName )                             //
// This class presents methods which permit easily read Registry data from JS.     //
// It encapsulates WMI class StdRegProv methods to get and convert necessary data. //
// See reference of the WMI class StdRegProv at:                                   //
// https://msdn.microsoft.com/en-us/library/aa393664(v=vs.85).aspx - reference     //
//                                                                                 //
// This class exports wrapper class methods for likewise StdRegProv methods:       //                                                             //                                                             //
// RegEnumSubKey(    root, regPath )                                               //
// RegEnumValues(    root, regPath )                                               //
// RegCheckAccess(   root, regPath )                                               //
// RegGetDWORDValue(          root, regPath, valueName )                           //
// RegGetQWORDValue(          root, regPath, valueName )                           //
// RegGetBinaryValue(         root, regPath, valueName )                           //
// RegGetStringValue(         root, regPath, valueName )                           //
// RegGetMultiStringValue(    root, regPath, valueName )                           //
// RegGetExpandedStringValue( root, regPath, valueName )                           //
//                                                                                 //
// CreateKey( root, regPath )                                                      //
// RegCreateKey( root, regPath, key )                                              //
// RegCreatePath( root, regPath, Path )                                            //
//                                                                                 //
// DeleteKey( root, regPath )                                                      //
// RegDeleteKey( root, regPath )                                                   //
// DeleteValue( root, regPath, valueName )                                         //
// RegDeleteValue( root, regPath, valueName )                                      //
//                                                                                 //
// SetDWORDValue(          root, regPath, valueName, value )                       //
// SetQWORDValue(          root, regPath, valueName, value )                       //
// SetBinaryValue(         root, regPath, valueName, value )                       //
// SetStringValue(         root, regPath, valueName, value )                       //
// SetMultiStringValue(    root, regPath, valueName, value )                       //
// SetExpandedStringValue( root, regPath, valueName, value )                       //
//                                                                                 //
// RegSetDWORDValue(          root, regPath, valueName, value )                    //
// RegSetQWORDValue(          root, regPath, valueName, value )                    //
// RegSetBinaryValue(         root, regPath, valueName, value )                    //
// RegSetStringValue(         root, regPath, valueName, value )                    //
// RegSetMultiStringValue(    root, regPath, valueName, value )                    //
// RegSetExpandedStringValue( root, regPath, valueName, value )                    //
//---------------------------------------------------------------------------------//
// This class exports it's own methods based on the methods listed above:          //                                                   //
// RegGetValue(     root, regPath, valueObj  )                                     //
// RegGetAllValues( root, regPath ) => { name: vName, type: vType, value: vValue } //
//---------------------------------------------------------------------------------//
// This class exports it's own methods:                                            //
// RegDateToDate( dword / qword )                                                  //
// SetServer = function( name )                                                    //
// SetWarnings = function( level )                                                 //
// SetUseCallCounts( level )                                                       //
// GetCallCounts()                                                                 //
// GetVersion()                                                                    //
/////////////////////////////////////////////////////////////////////////////////////

function StdRegWrapperClass( ServerName )
{
/*
--------------------------------------------------------------------------------------
RegRead 1-st was used in BCDS-FromReg01.js at 11.04.2015 and then was referenced in 92
files in f:\Delme\CleanBCD\archive
WbemScripting.SWbemLocator 1-st was used in BCDS-FromReg01.js at 11.04.2015 and then
was referenced in 154 files in f:\Delme\CleanBCD\archive
Thus:
version 01 continued from 01.00 till 01.091
version 02 continued from 02.00 till 02.154 at June 18 2015
--------------------------------------------------------------------------------------
"02.154 June 18 2015" - call of GetCurrentUserSID( regObj ) was implemented into
                        constructor as no one method of this class can be run untill
                        constructor finished, June 19, version number incremented.
"02.155 June 19 2015"   Output bufferization can be enabled by the caller, June 23
"02.156 June 23 2015"   Method RegGetEnumValues implemented at July 27
"02.157 July 27 2015"   parseInt( CurrentVersionObject.CurrentBuild ) implemented at July 28
"02.158 July 28 2015"   RegDateToDate fixed at August 13 
"02.159 August 13 2015" All Create/Delete/Set methods code implemented. A lot of other 
                        refactoring done. 
"02.160 August 18 2015" All Enum, Get methods runs fine as testcase shows. RegCreatePath
                        also WAD ==> RegCreateKey runs fine.
"02.161 August 18 2015" RegSetMultiStringValue, RegSetBinaryValue runs fine 
"02.162 August 18 2015" all methods and test cases runs fine, August 19-20: test cases 
"02.164 August 20 2015" some clearence, nothing new
*/
   this.OutBuffers = null; // June 23, implemented

   this.Out = {};
   this.Out.StdErr = WScript.StdErr;
   this.Out.StdOut = WScript.StdOut;

   if ( typeof( ServerName ) == "undefined" )
   {
      ServerName = "."; // local machine
   }

   var Version = "02.165 August 21 2015"; // final, I hope :)

   this.GetVersion = function()
   {
      return Version;
   }

   var IgnoreWarnings = true;    // can be changed by the caller
   var UseCallCounts  = false;   // can be changed by the caller

   var Usage = {
                  "RegEnumKey":             0,
                  "RegEnumValues":          0,
                  "RegCheckAccess":         0,
                  "RegGetDWORDValue":       0,
                  "RegGetQWORDValue":       0,
                  "RegGetBinaryValue":      0,
                  "RegGetStringValue":      0,
                  "RegGetMultiStringValue": 0,
                  "RegGetExpandedStringValue": 0,
                  "CreateKey":              0, "RegCreateKey":              0,
                  "SetBinaryValue":         0, "RegSetBinaryValue":         0,
                  "SetStringValue":         0, "RegSetStringyValue":        0,  
                  "SetMultiStringValue":    0, "RegSetMultiStringValue":    0,  
                  "SetExpandedStringValue": 0, "RegSetExpandedStringValue": 0,  
                  "SetDWORDValue":          0, "RegSetDWORDValue":          0,  
                  "SetQWORDValue":          0, "RegSetQWORDValue":          0,
                  "DeleteKey":              0, "RegDeleteKey":              0,     
                  "DeleteValue":            0, "RegDeleteValue":            0,
                  "RegDeleteAllValues":     0,
                  "RegDateToDate":          0,
                  "RegCreatePath":          0,
                  "RegGetValue":            0,
                  "RegGetAllValues":        0,
                  "RegGetEnumValues":       0                
               };

   var HKCR = 0x80000000;// HKEY_CLASSES_ROOT
   var HKCU = 0x80000001;// HKEY_CURRENT_USER
   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var HKCC = 0x80000005;// HKEY_CURRENT_CONFIG

   //
   // service objects required for all methods in the class
   //
   var objLocator  = new ActiveXObject( "WbemScripting.SWbemLocator" );
   var objService  = objLocator.ConnectServer( ServerName, "root\\default" );
   var objReg      = objService.Get( "StdRegProv" );
   var objMethod   = null;
   var objInParam  = null;
   var objOutParam = null;

   //
   // this method returns Version of this class.
   //
   this.GetVersion = function()
   {
      return Version;
   }

   //
   // this method returns object of StdRegProv class.
   //
   this.GetStdRegProvService = function()
   {
      return objReg;
   }

   //
   // this method sets name of the network server.
   //
   this.SetServer = function( name )
   {
      if ( typeof( name ) == "string" )
      {
         ServerName = name;
         objService  = objLocator.ConnectServer( ServerName, "root\\default" );
      }

      return ( ServerName == name );
   }

   //
   // this method sets value of the IgnoreWarings flag.
   // Caller could disable or enable output of the warning
   // messages as soon as an instance of the StdRegWrapperClass
   // was created by running this method.
   //
   this.SetWarnings = function( level )
   {
      if ( typeof( level ) == "undefined" )
      {
         IgnoreWarnings = false;
      }
      else
      {
         IgnoreWarnings = level ? false : true;
      }

      return IgnoreWarnings;
   }

   //
   // this method sets value of the UseCallCounts flag.
   // Caller could disable or enable support of the
   // counters for each of the methods called
   //
   this.SetUseCallCounts = function( level )
   {
      if ( typeof( level ) == "undefined" )
      {
         UseCallCounts = true;
      }
      else
      {
         UseCallCounts = level ? true : false;
      }
      if ( UseCallCounts )
      {
         for ( var p in Usage )
         {
            Usage[ p ] = 0;
         }
      }
      return UseCallCounts;
   }

   //
   // this method returns Usage object.
   //
   this.GetCallCounts = function()
   {
      return Usage;
   }

   function IncrementMethodCount( methodName )
   {
      if ( UseCallCounts ) // if caller have requested
      {
         if ( typeof( Usage[ methodName ] ) != "number" )
         {
            Usage[ methodName ] = 0;   
         }
         Usage[  methodName ]++;
         return Usage[  methodName ];
      }
      return 0;
   }

   //
   // Function to parse and verify input parameters, set correct
   // properties for the objInParam and run StdRegProv method.
   // Output parameters are then analysed and a warning message
   // is issued on StdErr provided warnings flag permits warnings.
   //
   // IT DOES NOT SUPPORT Create, Set, Delete METHODS, see function
   // RunCreateDeleteSetMethod below.
   //
   function RunGetOrEnumMethod( methodname, root, regPath, valueName )
   {
      //
      // output parameters lists for each method of the class
      //
      var methodsParams = {
         "CheckAccess":            "bGranted",
         "EnumKey":                "sNames",
         "EnumValues":             "sNames,Types", // Types: int32 array
         "GetStringValue":         "sValue",
         "GetExpandedStringValue": "sValue",
         "GetMultiStringValue":    "sValue",
         "GetDWORDValue":          "uValue",
         "GetQWORDValue":          "uValue",
         "GetBinaryValue":         "uValue"
      };

      var msg = "";

      if ( typeof( methodname ) != "string"  )
      {
         WScript.StdErr.WriteLine( "*** inavalid methodname " );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }

      IncrementMethodCount( methodname );
      
      if ( typeof( root ) != "number"
      ||   root < HKCR || root > HKCC || root == 0x80000004 )
      {
         WScript.StdErr.WriteLine( "*** Method " + RegMethod + " incorrect root=" + root );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }
      
      if ( typeof( regPath ) != "string" )//|| regPath.indexOf( "\\" ) == - 1 )
      {
         WScript.StdErr.WriteLine( "*** Method " + RegMethod + " incorrect regPath=" + regPath );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }

      if ( arguments.length == 4 && typeof( valueName ) != "string" )
      {
         WScript.StdErr.WriteLine( "*** Method " + RegMethod + " incorrect valueName=" + valueName );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }

      var RegMethod = "Reg" + methodname;

      if ( typeof( methodsParams[ methodname ] ) == "undefined" ) // verify that a correct
      {                                                           // method name is given
         msg = "*** Method " + RegMethod + " is absent in StdRegWrapperClass";
      }

      var IsValueName = ( arguments.length == 4 );

      if ( methodname.substr( 0, 3 ) == "Get" && ! IsValueName )
      {
         msg = "*** Parameter valuename is required for the method " + RegMethod;
      }

      if ( msg.length )
      {
         Out.StdErr.WriteLine( msg );
         if ( msg.indexOf( "valuename"    ) > - 1
         ||   msg.indexOf( "Invalid root" ) > - 1 )
         {
            Out.StdErr.WriteLine( "RegMethod " + RegMethod );
            Out.StdErr.WriteLine( "root "      + root      );
            Out.StdErr.WriteLine( "regPath "   + regPath   );
            Out.StdErr.WriteLine( "valuename " + typeof( valuename ) );
         }
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }


      objMethod   = objReg.Methods_.Item( methodname );
      objInParam  = objMethod.InParameters.SpawnInstance_();
      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;

      if ( IsValueName )
      {
         objInParam.sValueName = valueName;
      }

      if ( ( methodsParams[ methodname ] == "bGranted" ) )
      {  // for property subpath objOutParam.ReturnValue = 2 regardless 1 or 9
         objInParam.uRequired = 9;// KEY_QUERY_VALUE + KEY_ENUMERATE_SUB_KEYS
      }

      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); // run StdRegProv method

      var res = null;

      if ( objOutParam.ReturnValue != 0 )
      {
         if ( IgnoreWarnings ) return res;

         var msg = "*** StdRegProv method " + RegMethod  +
         " ReturnValue = " + objOutParam.ReturnValue + " for the path " + regPath;

         if ( IsValueName )
         {
             msg  += ", value name = " +
             ( typeof( valueName ) == "undefined" ? "undefined" : valueName );
         }
         Out.StdErr.WriteLine( msg );
         return res;
      }

      //
      // for Get-methods we return value which name
      // is given by methodsParams[ methodname ]
      //
      if ( methodname.startsWith( "Get" ) )
      {
         return objOutParam[ methodsParams[ methodname ] ];
      }

      //
      // for enum-methods we always return an array
      //
      var outParams = methodsParams[ methodname ].split( "," );

      res = {};

      for ( var i = 0; i < outParams.length; i++ )
      {
         res[ outParams[ i ] ] = objOutParam[ outParams[ i ] ];
      }

      return res;

   }// End-of-RunGetOrEnumMethod function
   
   //
   // Function to run 'native' Create, Delete, Set methods.
   // It doesn't verify input arguments. See correspondent Reg-methods
   // which verifies arguments and then run these 'native' methods
   //
   function RunCreateDeleteSetMethod( methodname, root, regPath, valueName, value )
   {
      IncrementMethodCount( methodname );
      objMethod  = objReg.Methods_.Item( methodname );
      objInParam = objMethod.InParameters.SpawnInstance_();
      objInParam.hDefKey     = root;    
      objInParam.sSubKeyName = regPath;
      if ( arguments.length >= 4  )// all Set methods and DeleteValue method
      {
         objInParam.sValueName  = valueName;

         if ( arguments.length == 5 )
         {
            if ( methodname.indexOf( "String" ) > - 1 )
            { 
               objInParam.sValue = value;  
            }
            else
            {   
               objInParam.uValue = value;
            }
         }
      }
      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam );
      return objOutParam.ReturnValue;
   }

   //
   // 5, 6, 8, 9, 10 are not supported by StdRegProv methods
   //
   /*
       5: "REG_DWORD_BIG_ENDIAN",           // 32-bit number
       6: "REG_LINK",                       // Symbolic Link (unicode)
       8: "REG_RESOURCE_LIST",              // Resource list in the resource map
       9: "REG_FULL_RESOURCE_DESCRIPTOR",   // Resource list in the hardware description
      10: "REG_RESOURCE_REQUIREMENTS_LIST", //
   */
   var InterpreteRegValueType = {
       0: "REG_NONE",                       // No value type
       1: "REG_SZ",                         // Unicode nul terminated string
       2: "REG_EXPAND_SZ",                  // Unicode nul terminated string
                                            //    (with environment variable references)
       3: "REG_BINARY",                     // Free form binary
       4: "REG_DWORD",                      // 32-bit number
       5: "REG_DWORD_BIG_ENDIAN",           // 32-bit number
       6: "REG_LINK",                       // Symbolic Link (unicode)
       7: "REG_MULTI_SZ",                   // Multiple Unicode strings
       8: "REG_RESOURCE_LIST",              // Resource list in the resource map
       9: "REG_FULL_RESOURCE_DESCRIPTOR",   // Resource list in the hardware description
      10: "REG_RESOURCE_REQUIREMENTS_LIST", //
      11: "REG_QWORD"                       // 64-bit number
   };

   //
   // Predefined Value Types from WinNT.h
   //

   var REG_NONE                       =  0; // No value type
   var REG_SZ                         =  1; // Unicode nul terminated string
   var REG_EXPAND_SZ                  =  2; // Unicode nul terminated string
                                            // (with environment variable references)
   var REG_BINARY                     =  3; // Free form binary
   var REG_DWORD                      =  4; // 32-bit number
   var REG_DWORD_BIG_ENDIAN           =  5; // 32-bit number
   var REG_LINK                       =  6; // Symbolic Link (unicode)
   var REG_MULTI_SZ                   =  7; // Multiple Unicode strings
   var REG_RESOURCE_LIST              =  8; // Resource list in the resource map
   var REG_FULL_RESOURCE_DESCRIPTOR   =  9; // Resource list in the hardware description
   var REG_RESOURCE_REQUIREMENTS_LIST = 10; //
   var REG_QWORD                      = 11; // 64-bit number

   //
   // Receives: Array of uint8
   // Returns:  Heximal string or array of strings joined by ","
   //
   function RegBinaryToHexString( binVal )
   {
      function Byte2Hex( b )
      {
         var bhex = b.toString( 16 );
         if ( bhex.length < 2 ) bhex = "0" + bhex;
         return bhex;
      }
      function Uint8ArrayToHexString( vals )
      {
         var tmp = "";

         for ( var i = 0; i < vals.length; i++)
         {
            tmp += Byte2Hex( vals[ i ] );
         }
         return tmp;
      }
      return Uint8ArrayToHexString( binVal );
   }

   // VerifyRegSetInput = function( root, regPath, valueName, valueType )
   // method returns:
   //  0 - if valuname doesn't exist or exist and has a type defined by valueType
   //  1 - value exist but valueType is incorrect
   //  2 - access to regpath is not granted
   // 11 - incorrect root value
   // 12 - incorrect value of one of the arguments
   //
   // valueType should be one of the:
   // "String", "MultiString", "ExpandedString", "Binary", "DWORD", "QWORD" 
   //
   this.VerifyRegSetInput = function( root, regPath, valueName, valueType )
   {
      var allTypes = "string,multistring,expandedstring,binary,dword,qword";
      var vt = valueType.toLowerCase();

      // check root
      if ( typeof( root ) != "number"
      ||   root < HKCR || root > HKCC || root == 0x80000004 ) return 11;
      
      // check other arguments
      if ( typeof( regPath   ) != "string"
      ||   typeof( valueName ) != "string"
      ||   typeof( valueType ) != "string"
      ||   allTypes.indexOf( vt ) == - 1 ) return 12;

      // check if enumeration and set value are permitted for regpath
      objMethod  = objReg.Methods_.Item( "CheckAccess" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;
      objInParam.uRequired    = 11;//KEY_QUERY_VALUE+KEY_SET_VALUE+KEY_ENUMERATE_SUB_KEYS

      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); 
      
      if ( objOutParam.ReturnValue != 0 ) return 2; // access

      // Enumerate all values     
      var valuesObj = this.RegEnumValues( root, regPath );
      if ( ! valuesObj || ! valuesObj.length ) return 0; // no one value exist

      // check if valuename exist and verify valuetype
      var type = "";
      var vt = valueName.toLowerCase();
      for ( var i = 0; i < valuesObj.length; i++ )
      {
         if ( valuesObj[ i ].name.toLowerCase() == vt )
         {
            switch( vt )
            {
               case "string":         type = REG_SZ;        break;
               case "multistring":    type = REG_MULTI_SZ;  break;
               case "expandedstring": type = REG_EXPAND_SZ; break;
               case "binary":         type = REG_BINARY;    break;
               case "dword":          type = REG_DWORD;     break;
               case "qword":          type = REG_QWORD;     break;
            }
            if ( type == valuesObj[ i ].type ) return 0;
            return 1;
         }
      }
      return 0; // key doesn't exist     
   }

   // VerifyRegCreateInput = function( root, regPath, valueName, valueType )
   // method returns:
   //  0 - if valuname doesn't exist or exist and has a type defined by valueType
   //  1 - value exist but valueType is incorrect
   //  2 - access to regpath is not granted
   // 11 - incorrect root value
   // 12 - incorrect value of one of the arguments
   //
   this.VerifyRegCreateInput = function( root, regPath, key )
   {
      if ( typeof( root ) != "number"
      ||   root < HKCR || root > HKCC || root == 0x80000004 )
      {
         Out.StdErr.WriteLine( "VerifyRegCreateInput: incorrect root value " + root + 
         ", regPath = " + regPath ); 
         return 11;
      }

      if ( typeof( regPath ) != "string"
      ||   typeof( key ) != "string" )
      {
         Out.StdErr.WriteLine( "VerifyRegCreateInput: incorrect regPath " + regPath ); 
         return 12;
      }

      objMethod  = objReg.Methods_.Item( "CheckAccess" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;
      objInParam.uRequired   = 4 + 8 + 32;//KEY_CREATE_SUB_KEY+KEY_ENUMERATE_SUB_KEYS+KEY_CREATE
      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); 
      
      if ( objOutParam.ReturnValue != 0 )
      { 
         Out.StdErr.WriteLine( "VerifyRegCreateInput: CheckAccess ReturnValue 2 for regPath = " + regPath );
         return 2; // access 
      } 
    
      objMethod  = objReg.Methods_.Item( "EnumKey" );
      objInParam = objMethod.InParameters.SpawnInstance_();
      objInParam.hDefKey     = root;    
      objInParam.sSubKeyName = regPath; 
      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam );

      if( objOutParam.ReturnValue != 0 )
      {
         Out.StdErr.WriteLine( "VerifyRegCreateInput: EnumKey ReturnValue for regPath = " + regPath );
         return 1;
      }
      if ( objOutParam.sNames == null
      ||   typeof( objOutParam.sNames.toArray().length ) != "number" ) 
      {
         return 0;
      }      

      var tmp = objOutParam.sNames.toArray().join( "," ).toLowerCase();
      if ( tmp.indexOf( key.toLowerCase() ) > - 1 ) return 2; // key exists 
      return 0;
   }

   // VerifyRegDeleteInput = function( root, regPath )
   // method returns:
   //  0 - can be deleted
   //  2 - access to regpath is not granted
   // 11 - incorrect root value
   // 12 - incorrect value of one of the arguments
   //
   this.VerifyRegDeleteInput = function( root, regPath, valueName )
   {
      // DeleteKey - two arguments, DeleteValue - three arguments
      if ( typeof( root ) != "number"
      ||   root < HKCR || root > HKCC || root == 0x80000004 ) return 11;

      if ( typeof( regPath ) != "string" ) return 12;
      if ( arguments.length == 3 && typeof( valueName ) != "string" ) return 12;

      objMethod  = objReg.Methods_.Item( "CheckAccess" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;
      objInParam.uRequired   = arguments.length == 2 ? 65536 : 3;
      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); 
      
      if ( objOutParam.ReturnValue != 0 ) return 2; // access 
      return 0;
   }

   /*
   -------------------------------------------------------------------------------------------------
      uint32 CheckAccess(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           uint32 uRequired = 3,
      [out]          bool bGranted
      );
   -------------------------------------------------------------------------------------------------
   KEY_QUERY_VALUE,         1 (0x1), Required to query the values of a registry key.
   KEY_SET_VALUE,           2 (0x2), Required to create, delete, or set a registry value.
   KEY_CREATE_SUB_KEY,      4 (0x4), Required to create a subkey of a registry key.
   KEY_ENUMERATE_SUB_KEYS,  8 (0x8), Required to enumerate the subkeys of a registry key.
   KEY_NOTIFY,            16 (0x10), Required to request change notifications for a registry
                                     key or for subkeys of a registry key.
   KEY_CREATE,           32 (0x20),  Required to create a registry key.
   DELETE,          65536 (0x10000), Required to delete a registry key.
   READ_CONTROL,   131072 (0x20000), Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE,
                                     KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY values.
   WRITE_DAC,      262144 (0x40000), Required to modify the DACL in the object's security descriptor.
   WRITE_OWNER,    524288 (0x80000), Required to change the owner in the object's security descriptor.
   -------------------------------------------------------------------------------------------------
   KEY_QUERY_VALUE | KEY_SET_VALUE, 3, Default value, allows querying, creating,
                                       deleting, or setting a registry value.
   -------------------------------------------------------------------------------------------------
   */
   this.RegCheckAccess = function( root, regPath )
   {
      return RunGetOrEnumMethod( "CheckAccess", root, regPath );
   }

   /*
   --------------------------------------------------------------------------
   uint32 GetSecurityDescriptor(
      [in]  uint32               hDefKey = HKEY_LOCAL_MACHINE,
      [in]  string               sSubKeyName,
      [out] __SecurityDescriptor Descriptor
   );
   --------------------------------------------------------------------------
   */
   this.RegGetSecurityDescriptor = function( root, regPath )
   {
      objMethod  = objReg.Methods_.Item( "GetSecurityDescriptor" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;

      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam );

   }// End-of-RegGetSecurityDescriptor

   /*
   --------------------------------------------------------
   uint32 EnumKey(
       [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
       [in]           string sSubKeyName,
       [out]          string sNames[]
   );
   --------------------------------------------------------
   */
   this.RegEnumKey = function( root, regPath )
   {
      var res = RunGetOrEnumMethod( "EnumKey", root, regPath );
      if ( res == null
      ||   res.sNames == null
      ||   typeof( res.sNames ) == "undefined"  ) return [];
      return res.sNames.toArray();
   }

   /*
   --------------------------------------------------------
   uint32 EnumValues(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [out]          string sNames[],
      [out]          sint32 Types[]
   );
   --------------------------------------------------------
   */
   this.RegEnumValues = function ( root, regPath )
   {
      var res = RunGetOrEnumMethod( "EnumValues", root, regPath );
      if ( res == null 
      ||   typeof( res.sNames ) == "undefined"
      ||   res.sNames == null ) return [];
      var names = res.sNames.toArray();
      var types = res.Types.toArray();
      var ret   = [];

      for ( var i = 0; i < types.length; i++ )
      {
         ret[ i ] = { "name": names[ i ], "type": types[ i ] };
      }

      return ret;
   }

   /*
   --------------------------------------------------------------
   uint32 GetBinaryValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint8  uValue[]
   );
   ---------------------------------------------------------------
   */
   this.RegGetBinaryValue = function ( root, regPath, valueName, flag )
   {
      var res = RunGetOrEnumMethod( "GetBinaryValue", root, regPath, valueName );
      if ( res == null ) return res;
      if ( arguments.length == 4 ) return res;
      return RegBinaryToHexString( VBArray( res ).toArray() );
   }

   /*
   ---------------------------------------------------------------
   uint32 GetStringValue(
     [in]  uint32 hDefKey = HKEY_LOCAL_MACHINE,
           string sSubKeyName,
           string sValueName,
     [out] string sValue
   );
   ---------------------------------------------------------------
   */
   this.RegGetStringValue = function ( root, regPath, valueName )
   {
      return RunGetOrEnumMethod( "GetStringValue", root, regPath, valueName );
   }

   /*
   -----------------------------------------------------------------------
   uint32 GetExpandedStringValue(
     [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in]           string sSubKeyName,
     [in]           string sValueName,
     [out]          string sValue
    );
   -----------------------------------------------------------------------
   */
   this.RegGetExpandedStringValue = function ( root, regPath, valueName )
   {
      return RunGetOrEnumMethod( "GetExpandedStringValue", root, regPath, valueName );
   }

   /*
   --------------------------------------------------------------
   uint32 GetDWORDValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint32 uValue
   );
   --------------------------------------------------------------
   */
   this.RegGetDWORDValue = function ( root, regPath, valueName )
   {
      return RunGetOrEnumMethod( "GetDWORDValue", root, regPath, valueName );
   }

   /*
   --------------------------------------------------------------
   uint32 GetQWORDValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint64 uValue
   );
   --------------------------------------------------------------
   */
   this.RegGetQWORDValue = function ( root, regPath, valueName )
   {
      return RunGetOrEnumMethod( "GetQWORDValue", root, regPath, valueName );
   }

   /*
   -----------------------------------------------------------------
   uint32 GetMultiStringValue(
     [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in]           string sSubKeyName,
     [in]           string sValueName,
     [out]          string sValue[]
   );
   -----------------------------------------------------------------
   */
   this.RegGetMultiStringValue = function( root, regPath, valueName, ReturnVBArray )
   {
      var res = RunGetOrEnumMethod( "GetMultiStringValue", root, regPath, valueName );
      if ( arguments.length == 4 ) return res;
      return res.toArray().join( "," );
   }

   /*
   ---------------------------------------------------------
   RegGetValue(
      [in] { "name:" vName, "type": vType }
   );
   [out] - depends on the type of the value with given name
   ---------------------------------------------------------
   */
   this.RegGetValue = function( root, regPath, valueObj )
   {
      IncrementMethodCount( "RegGetValue" );
      var name = valueObj.name;
      var type = valueObj.type, val = null;
      switch( type )
      {
         case REG_SZ:       { val = this.RegGetStringValue(         root, regPath, name ); break; }
         case REG_EXPAND_SZ:{ val = this.RegGetExpandedStringValue( root, regPath, name ); break; }
         case REG_MULTI_SZ: { val = this.RegGetMultiStringValue(    root, regPath, name ); break; }
         case REG_BINARY:   { val = this.RegGetBinaryValue(         root, regPath, name ); break; }
         case REG_NONE:     { val = this.RegGetStringValue(         root, regPath, name ); break; }
         case REG_DWORD:    { val = this.RegGetDWORDValue(          root, regPath, name ); break; }
         case REG_QWORD:    { val = this.RegGetQWORDValue(          root, regPath, name ); break; }
      }

      return { "name": name, "type": InterpreteRegValueType[ type ], "value": val };
   }

   /*
   ----------------------------------------------------------------------
   RegGetAllValues( root, regPath )
   returns an array of objects { "name": vName, "value": vValue }
   ----------------------------------------------------------------------
   */
   this.RegGetAllValues = function( root, regPath )
   {
      IncrementMethodCount( "RegGetAllValues" );
      var valuesObj = this.RegEnumValues( root, regPath );
      if ( ! valuesObj || ! valuesObj.length ) return [];
      var res = [];

      for ( var i = 0; i < valuesObj.length; i++ )
      {
         if ( valuesObj[ i ].type > REG_MULTI_SZ 
         ||   valuesObj[ i ].type == REG_LINK ) continue;

         // REG_LINK                        6
         // REG_RESOURCE_LIST               8
         // REG_FULL_RESOURCE_DESCRIPTOR    9
         // REG_RESOURCE_REQUIREMENTS_LIST 10

         res[ res.length ] = this.RegGetValue( root, regPath, valuesObj[ i ] );
      }
      return res;
   }

   /*
   ----------------------------------------------------------------------
   RegGetEnumValues( root, regPath )
   Special case of the RegGetAllValues( root, regPath ) which reads
   all values of Enumeration of the objects. In this case REG_DWORD
   with a name Count is read at first and then in the loop [0-Count-1]
   RegSZ values with a names i.toString() are read one by one and
   values are placed into an output array. If the value read contains
   "" than such a value is not placed into the output array. Likewise
   values are present in enumerations of the objects in Windows 9600-.
   ----------------------------------------------------------------------
   */
   this.RegGetEnumValues = function( root, regPath, flag )
   {
      IncrementMethodCount( "RegGetEnumValues" );
      var Count = this.RegGetDWORDValue( root, regPath, "Count" );
      if ( typeof( flag ) == "undefined" )
      {
         flag = false;
      }

      var res = [], val;

      for ( var i = 0; i < Count; i++ )
      {
         val = this.RegGetStringValue( root, regPath, i.toString() );

         if ( ! flag )
         {
            if ( val.indexOf( "LEGACY_" ) > - 1 ) continue;
         }
         res[ res.length ] = val;
      }
      return res;
   }
   //
   // this method converts registry REG_QDWORD number which presents Date to
   // standard JS Date object and returns it.
   //
   // https://msdn.microsoft.com/en-us/library/aa393041(v=vs.85).aspx
   // Unique value that indicates the time when an event is generated. This is a 64-bit 
   // FILETIME value that represents the number of 100-nanosecond intervals after January 1, 1601. 
   // The information is in the Coordinated Universal Time (UTC) format. This property is inherited 
   // from __Event. To convert this value to other time formats, use the SWbemDateTime methods 
   // SetFileTime and GetFileTime. For more information, see WMI Tasks: Dates and Times.
   //
   this.RegDateToDate = function( regDate )
   {
      IncrementMethodCount( "RegDateToDate" );

      var MaxDWORD = 0x100000000;

      if ( regDate < MaxDWORD )// if RegDate is REG_DWORD
      {
         return new Date( 1000 * regDate );
      }
      
      var since1601 = 11644473600000; // till 01/01/1970
      var MilliSeconds = Math.round( regDate / 10000 ) - since1601;
      return new Date( MilliSeconds );
   }

   //
   // Set of Create, Set, Delete methods, August 16, 2015
   //

   /*
   -----------------------------------------------------------------
   uint32 CreateKey(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] String sSubKeyName
   );
   -----------------------------------------------------------------
   */
   this.CreateKey = function( root, regPath )// fast, 'native' method
   {
      return RunCreateDeleteSetMethod( "CreateKey", root, regPath ); 
   }

   this.RegCreateKey = function( root, regPath, key )// slow, StdRegWrapper class method
   {
      IncrementMethodCount( "RegCreateKey" );
      var rc = this.VerifyRegCreateInput( root, regPath, key );
      if ( rc ) return rc;
      return this.CreateKey( root, regPath + "\\" + key );
   }

   this.RegCreatePath = function( root, regPath, Path )// fast, StdRegWrapper class method
   {
      IncrementMethodCount( "RegCreatePath" );
      var rc = this.VerifyRegCreateInput( root, regPath, Path );
      if ( rc ) return rc; 

      var tmp = Path.split( "\\" );
  
      objMethod  = objReg.Methods_.Item( "CreateKey" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      for ( var i = 0; i < tmp.length; i++ )
      {
         objInParam.hDefKey     = root;    
         objInParam.sSubKeyName = regPath + "\\" + tmp[ i ];
         regPath  = objInParam.sSubKeyName;
         objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); 
         if ( objOutParam.ReturnValue != 0 ) return objOutParam.ReturnValue;          
      }   
      return objOutParam.ReturnValue;
   }
   
   /*
   -----------------------------------------------------------------
   uint32 SetBinaryValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] uint8  uValue[]  
   );
   -----------------------------------------------------------------
   */
   this.SetBinaryValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetBinaryValue", root, regPath, valueName, value ); 
   }

   //
   // Parameter value SHOULD be VBarray and thus can not be prepared
   // by JavaScript code 
   //
   this.RegSetBinaryValue = function( root, regPath, valueName, value )
   {
      IncrementMethodCount( "RegSetBinaryValue" );
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "Binary" );
      if ( rc ) return rc;
/*
      // temporary excluded input VBarray content verification
      if ( typeof( value ) != object 
      ||   typeof( value.length ) != "number" 
      ||   value.length == 0 ) return 3;
      for ( var i = 0; i < value.length; i++ )
      {
         if ( value[ i ] > 255 || value[ i ] < 0 ) return 4;
      }
*/
      return this.SetBinaryValue( root, regPath, valueName, value );
   }

   /*
   -----------------------------------------------------------------
   uint32 SetDWORDValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] uint32 uValue = 
   );
   -----------------------------------------------------------------
   */
   this.SetDWORDValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetDWORDValue", root, regPath, valueName, value ); 
   }
   this.RegSetDWORDValue = function( root, regPath, valueName, value )
   {
      IncrementMethodCount( "RegSetDWORDValue" );
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "DWORD" );
      if ( rc ) return rc;
      if ( typeof( value ) != "number" ) return 3;
      return this.SetDWORDValue( root, regPath, valueName, value );
   }

   /*
   -----------------------------------------------------------------
   uint32 SetQWORDValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] uint64 uValue = 
   );
   -----------------------------------------------------------------
   */
   this.SetQDWORDValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetQWORDValue", root, regPath, valueName, value ); 
   }
   this.RegSetQWORDValue = function( root, regPath, valueName, value )
   {
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "QWORD" );
      if ( rc ) return rc;
      if ( typeof( value ) != "number" ) return 3;
      IncrementMethodCount( "RegSetQWORDValue" );
      return this.SetQDWORDValue( root, regPath, valueName, value );
   }

   /*
   -----------------------------------------------------------------
   uint32 SetStringValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] string sValue = 
   );
   -----------------------------------------------------------------
   */ 
   this.SetStringValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetStringValue", root, regPath, valueName, value ); 
   }
   this.RegSetStringValue = function( root, regPath, valueName, value )
   {
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "String" );
      if ( rc ) return rc;
      if ( typeof( value ) != "string" ) return 3;
      IncrementMethodCount( "RegSetStringValue" );
      return RunCreateDeleteSetMethod( "SetStringValue", root, regPath, valueName, value );
   }

   /*
   -----------------------------------------------------------------
   uint32 SetExpandedStringValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] string sValue = 
   );
   -----------------------------------------------------------------
   */
   this.SetExpandedStringValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetExpandedStringValue", root, regPath, valueName, value ); 
   }
   this.RegSetExpandedStringValue = function( root, regPath, valueName, value )
   {
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "ExpandedString" );
      if ( rc ) return rc;
      if ( typeof( value ) != "string" ) return 3;
      IncrementMethodCount( "RegSetExpandedStringValue" );
      return this.SetExpandedStringValue( root, regPath, valueName, value );
   }
   
   /*
   -----------------------------------------------------------------
   uint32 SetMultiStringValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName,
     [in] string sValueName,
     [in] Variant sValue[] = An array of string data values
   );
   -----------------------------------------------------------------
   */
   this.SetMultiStringValue = function( root, regPath, valueName, value )
   {
      return RunCreateDeleteSetMethod( "SetMultiStringValue", root, regPath, valueName, value );
   }
   //
   // Parameter value SHOULD be VBarray and thus can not be prepared
   // by JavaScript code 
   //
   this.RegSetMultiStringValue = function( root, regPath, valueName, value )
   {
      var rc = this.VerifyRegSetInput( root, regPath, valueName, "MultiString" );
      if ( rc ) return rc;
/*
      // temporary excluded VBarray value content verification
      if ( typeof( value ) != "object" 
      ||   typeof( value.length ) != "number" 
      ||   value.length == 0 ) return 3;
      if ( typeof( value[ 0 ] ) != "string" ) return 4;
*/
      IncrementMethodCount( "RegSetMultiStringValue" );
      return this.SetMultiStringValue( root, regPath, valueName, value );
   }

   /*
   -----------------------------------------------------------------
   uint32 DeleteKey(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName
   );
   -----------------------------------------------------------------
   */
   this.DeleteKey = function( root, regPath )
   {
      return RunCreateDeleteSetMethod( "DeleteKey", root, regPath ); 
   }
   this.RegDeleteKey = function( root, regPath )
   {
      var rc = this.VerifyRegDeleteInput( root, regPath );
      if ( rc ) return rc;
      IncrementMethodCount( "RegDeleteKey" );
      return this.DeleteKey( root, regPath );
   }
   
   /*
   -----------------------------------------------------------------
   uint32 DeleteValue(
     [in] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in] string sSubKeyName
   );
   -----------------------------------------------------------------
   */
   this.DeleteValue = function( root, regPath, valueName )
   {
      return RunCreateDeleteSetMethod( "DeleteValue", root, regPath, valueName ); 
   }
   this.RegDeleteValue = function( root, regPath, valueName )
   {
      var rc = this.VerifyRegDeleteInput( root, regPath, valueName );
      if ( rc ) return rc;
      IncrementMethodCount( "RegDeleteValue" );
      return this.DeleteValue( root, regPath, valueName );
   }

   this.RegDeleteAllValues = function( root, regPath )
   {
      var rc;

      var valuesObj = this.RegEnumValues( root, regPath );
      if ( ! valuesObj || ! valuesObj.length ) return 1;
      IncrementMethodCount( "RegDeleteAllValues" );
      for ( var i = 0; i < valuesObj.length; i++ )
      {
         rc = this.DeleteValue( root, regPath, valuesObj[ i ].name );
      }

      return rc;
   }
 
   //-----------------------------------------------------------------------------
   // the only useful actions of the class constructor, tested at June 26, WAD
   //-----------------------------------------------------------------------------

   var MSSoft             = "SOFTWARE\\Microsoft\\";
   var CurrentVersionPath = MSSoft + "Windows NT\\CurrentVersion";
   var currentusername = this.RegGetStringValue( HKLM,
                         MSSoft + "Windows\\CurrentVersion\\Authentication\\LogonUI",
                         "LastLoggedOnUser" );

   var tmp, unamechunk, proot, profiles, puname, userprof; 
    
   if ( currentusername != null ) // all builds > 2600
   {
      //value looks like: ".\\sysprg".split( "\\" ) ==> { server, username };

      tmp = currentusername.split( "\\" ); // HERE XP detects NULL for currentusername
      unamechunk = tmp[ 1 ].substr( 0, 5 ) + "_"; // Windows 10 shortens usernames till 5 characters

      CurrentUserObject[ "CurrentServer"   ] = tmp[ 0 ];
      CurrentUserObject[ "CurrentUserName" ] = tmp[ 1 ];

      currentusername = tmp[ 1 ];

      // SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList

      proot = CurrentVersionPath + "\\ProfileList";
      profiles = this.RegEnumKey( HKLM, proot );
      puname;

      for ( var i = 0; i < profiles.length; i++ )
      {
         userprof = this.RegGetStringValue( HKLM, proot + "\\" + profiles[ i ], "ProfileImagePath" );
         puname = userprof.split( "\\" )[ userprof.split( "\\" ).length - 1 ];

         if ( currentusername == puname         // Windows7/8, local user
         ||   puname.startsWith( unamechunk ) ) // Windows 10, MS account name
         {
            CurrentUserObject[ "CurrentUserProfile" ] = userprof;
            CurrentUserObject[ "CurrentUserSID"     ] = profiles[ i ];
            CurrentUserSID = profiles[ i ];
         }
      }
   }
   else
   {
      tmp = this.RegGetStringValue( HKLM,
                                    "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit",
                                    "LastUsedDatabase" );
      // tmp looks like: c:\\docume~1\\marabul\\locals~1\\temp\\secedit.sdb
 
      currentusername = tmp.split( "\\" )[ 2 ];  
         
      tmp = this.RegGetAllValues( HKLM, "SYSTEM\\CurrentControlSet\\Control\\hivelist" );
 
      for ( var i = 0; i < tmp.length; i++ )
      {
         if ( tmp[ i ].value.indexOf( currentusername ) > - 1 ) break;
      }
      // tmp[i].name:  \\REGISTRY\\USER\\S-1-5-21-2714740780-1644625801-1678660887-1006"
      // tmp[i].value: \\Device\\HarddiskVolume1\\Documents and Settings\\marabul\\NTUSER.DAT
      
      CurrentUserSID = tmp[ i ].name.substr( tmp[ i ].name.indexOf( "S-" ) );
      CurrentUserObject[ "CurrentUserProfile" ] = currentusername;
      CurrentUserObject[ "CurrentUserSID"     ] = CurrentUserSID;
   }

   delete unamechunk, currentusername, proot, profiles, puname;

   tmp = this.RegGetAllValues( HKLM, CurrentVersionPath );

   //
   // for each Windows version, following keys always will
   // be present in the CurrentVersionObject:
   //
   // "ProductName"="Microsoft Windows XP", "CurrentBuildNumber"="2600",
   // "BuildLab"="2600.xpsp_sp3_qfe.150205-1510",
   //
   // "ProductName"="Windows 7 Enterprise", "CurrentBuildNumber"="7601",
   // "BuildLab"="7601.win7sp1_gdr.150427-0707",
   //
   // "ProductName"="Windows 8.1 Pro", "CurrentBuildNumber"="9600",
   // "BuildLab"="9600.winblue_r9.150322-1500",
   //
   // "ProductName"="Windows 10 Pro Insider Preview", "CurrentBuildNumber"="10130",
   // "BuildLab"="10130.fbl_impressive.150522-2224"
   //
   // CurrentVersionObject.CurrentBuildNumber
   //
   for( var i = 0; i < tmp.length; i++  )
   {
      CurrentVersionObject[ tmp[ i ].name ] =  tmp[ i ].value;
   }
   tmp = parseInt( CurrentVersionObject.CurrentBuild );
   CurrentVersionObject.CurrentBuild = tmp;
   delete tmp, MSSoft, CurrentVersionPath;

} // End-of-StdRegWrapperClass()

</script>                    <!-- StdRegWrapperClass TrailingTag -->
<script language="JScript">//<!-- TestCase-for-StdRegWrapperClass LeadingTag -->
'use strict';

String.prototype.HexString2ASCI = function()
{
   var tmp = this.split( "00" ).join( "" );
   var str = "";
   while ( tmp.length > 0 )
   {
      str += String.fromCharCode( parseInt( tmp.substr( 0, 2 ), 16 ) );
      tmp = tmp.substr( 2 );
   }
   return str;
}
if ( typeof( repeat ) == "undefined" )
{
   String.prototype.repeat = function( n )
   {
      var tmp = this;
      if ( tmp.length == n ) return tmp;
      while( tmp.length < n ) tmp += this;
      return tmp;
   }
}
String.prototype.left = function( n, char )
{
   if ( typeof( char ) == "undefined" ) char = " ";
   if ( this.length >= n ) return this.substr( 0, n );
   if ( this.length == n ) return this;
   return this + char.repeat( n - this.length );
}
String.prototype.right = function( n, char )
{
   if ( typeof( char ) == "undefined" ) char = " ";
   if ( this.length > n ) return this.substr( this.length - n );
   if ( this.length == n ) return this;
   return char.repeat( n - this.length ) + this;
}
//===========================================================================
// Test code for StdRegWrapperClass
//===========================================================================
var MyName = WScript.ScriptName;
var fso    = new ActiveXObject( "Scripting.FileSystemObject" );
var path   = fso.GetAbsolutePathName( "." );
var CreateLogFiles = false;
var UseStorageBuffers = false;
var Out  = {};
Out.StdErr  = WScript.StdErr;
Out.StdOut  = WScript.StdOut;
var regObj  = null;
var now     = null;

var rver;

var Version = "1.00 build 01 August 17 2015";
var started = new Date();

regObj = new StdRegWrapperClass();     // create an instance of the StdRegWrapperClass
regObj.SetWarnings( 0 );               // enable warnings
rver = regObj.GetVersion();            // get version of StdRegWrapperClass
regObj.SetUseCallCounts( 1 );          // enable counting of the calls

var OutLog = MyName + "-" + CurrentVersionObject.CurrentBuild + "-StdOut.txt";
var ErrLog = MyName + "-" + CurrentVersionObject.CurrentBuild + "-StdErr.txt";

Out.StdErr = fso.CreateTextFile( ErrLog, true, 0 );// overwrite, ascii
Out.StdOut = fso.CreateTextFile( OutLog, true, 0 );// overwrite, ascii

regObj.Out.StdErr = Out.StdErr;  // redefine Output for the StdRegWrapperClass
regObj.Out.StdOut = Out.StdOut;  // redefine Output for the StdRegWrapperClass

Out.StdOut.WriteLine( "\n" );
Out.StdOut.WriteLine( "Build "+CurrentVersionObject.CurrentBuild +
                      ", StdRegWrapperClass version " + rver );
Out.StdOut.WriteLine( "\n" );

var Run_TestcaseForCreatetSetMethods = false;
var Run_DeepDive                     = true;

if ( Run_TestcaseForCreatetSetMethods )
{
   TestcaseForCreatetSetMethods(); // Execute Test Case
}

if ( Run_DeepDive )
{
   RunDeepDive( 1 ); // Execute Test Case
}

var Counts = regObj.GetCallCounts();
Out.StdOut.WriteLine( "\n" );
for ( var p in Counts )         //  type counts table
{
   if ( ! Counts[ p ] ) continue;
   Out.StdOut.WriteLine( "StdRegWrapperClass method " + p.left( "RegSetExpandedStringValue".length ) +
   " was used " + Counts[ p ].toString().right( 4, " " ) + " times" );
}
Out.StdOut.WriteLine( "\n" );
Out.StdOut.WriteLine( "\n" );

var finished = new Date();
var duration, durmilli, durss, durmm, durhh, cdur;
var second   = 1000;
var minute   = second * 60;
var msg;

duration = finished.getTime() - started.getTime();
cdur = "Execution continued " + duration + " milliseconds";

if ( duration > second )
{
   durss = Math.round( duration / second );
   durmilli = ( duration + 999 ) % second;
   cdur = "Execution continued  "+durss + "." + durmilli + " seconds";
   if ( durss > 60 )
   {
      durmm = ( ( minute - 1 + duration ) / minute ).toFixed();
      durss =   ( minute - 1 + duration ) % minute;
      durmilli = durss % second;
      durss = ( ( second - 1 + durss ) / second ).toFixed();
      cdur  = "Execution continued " + durmm + " minutes " + durss + "." + durmilli + " seconds";
   }  
}

Out.StdOut.WriteLine( cdur );
WScript.Echo( cdur );

if ( fso != null )
{
   Out.StdErr.close();
   Out.StdOut.close();
}
WScript.Quit();

function PutMsg( rc, func, path, key )
{
   var maxl = "RegSetExpandedStringValue".length;
   var f    = func.length > maxl ? func : func.left( maxl );
   var msg  = rc + " " + f + " " + path;
   if ( arguments.length == 4 ) msg += " " + key;
   Out.StdOut.WriteLine( msg );
   return true;
}
//
// Run DeepDive test-case
//
function RunDeepDive( flag )
{
   flag = ( arguments.length == 0 ) ? false : true;

   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var DiveSpots = [ 
      { "root": HKLM, "path": "HARDWARE"                            }, 
      { "root": HKLM, "path": "SYSTEM\\CurrentControlSet\\Services" },
      { "root": HKLM, "path": "SYSTEM\\CurrentControlSet\\Enum"     },
      { "root": HKLM, "path": "SYSTEM\\CurrentControlSet\\Control"  },
      { "root": HKLM, "path": "SYSTEM\\CurrentControlSet\\Setup"    },
      { "root": HKLM, "path": "SYSTEM\\CurrentControlSet\\Software" },
      { "root": HKU,  "path": CurrentUserSID                        },
      { "root": HKU,  "path": CurrentUserSID + "_Classes"           }       
   ];

   var ret, RegObjects, obj, path, croot;
   var longest = "", MaxDepth = 1, deepest = "", msg;
   var MaxBinLength = 1;
   var MaxBinLengthName = "";
   var MaxBinLengthPath = "";

   for ( var p = 0; p < DiveSpots.length; p++ )
   {
      root = DiveSpots[ p ].root;
      path = DiveSpots[ p ].path;
      ret  = DeepDive( root, path, [] );
      RegObjects = ret.objects;
      croot = ( root == HKLM ) ? "HKLM" : "HCU";
      for ( var i = 0; i < RegObjects.length; i++ )
      {
         obj = RegObjects[ i ];
         msg = "";
         if ( obj.path.length > longest.length 
         ||   obj.path.split( "\\" ).length > MaxDepth )
         {
            if ( obj.path.length > longest.length )
            { 
               longest = obj.path;
            }
            else
            { 
               MaxDepth = obj.path.split( "\\" ).length;
               deepest  = obj.path;
               Out.StdOut.WriteLine( "MaxDepth" + obj.path.split( "\\" ).length );
            }
         }
         if ( obj.HasBinary )
         {
            if ( obj.MaxBinLength > MaxBinLength )
            {
               MaxBinLength = obj.MaxBinLength;
               MaxBinLengthName = obj.MaxBinLengthName;
               MaxBinLengthPath = obj.path;
            }
         }
         if ( flag )
         {
            Out.StdOut.WriteLine( croot + "\\"+obj.path );
            if ( obj.valuenames == "" )
            {
               Out.StdOut.WriteLine( "ValueNames=" );
               continue;
            } 
            Out.StdOut.WriteLine( "ValueNames="+obj.valuenames );
            Out.StdOut.WriteLine( "ValueTypes="+obj.valuetypes ); 
            if ( obj.HasBinary )
            {
               Out.StdOut.WriteLine( "BinaryValueNames="+obj.binvals );
            }
            if ( obj.dates != "" )
            {
               Out.StdOut.WriteLine( "Dates="+obj.dates ); 
            }
            if ( obj.HasSubKeys )
            {
               Out.StdOut.WriteLine( "Subkeys="+obj.subkeys ); 
            } 
            Out.StdOut.WriteLine( "\n" );      
         }
         else
         {
            Out.StdOut.WriteLine( croot + "\\"+obj.path );
            Out.StdOut.WriteLine( "valuenames="+obj.valuenames.split(",").length +
            " valuetypes="+obj.valuetypes.split(",").length + 
            " subkeys="+obj.subkeys.split(",").length + " " + obj.HasBinary );
            Out.StdOut.WriteLine( "\n" );
         }
      } // end-of-objects loop
      
      Out.StdOut.WriteLine( "\n" );
      Out.StdOut.WriteLine( MaxBinLengthName + " MaxBinLength = " + MaxBinLength + " at " + MaxBinLengthPath );
      Out.StdOut.WriteLine( "\n" );
   } // end-of-DiveSpots loop

   Out.StdOut.WriteLine( "\n" );
   Out.StdOut.WriteLine( "MaxDepth = " + MaxDepth + " at " + deepest );
   Out.StdOut.WriteLine( "Longest path = " + longest );
   Out.StdOut.WriteLine( "\n" );
   return true;
}
function DepthAndPathLengthDependanceTest()
{
}
function DeepDive( root, path, objects )
{
   var rc, subkeys, values, ret, obj, qw, qwr;
   var REG_NONE                       =  0; // No value type
   var REG_SZ                         =  1; // Unicode nul terminated string
   var REG_EXPAND_SZ                  =  2; // Unicode nul terminated string
                                            // (with environment variable references)
   var REG_BINARY                     =  3; // Free form binary
   var REG_DWORD                      =  4; // 32-bit number
   var REG_DWORD_BIG_ENDIAN           =  5; // 32-bit number
   var REG_LINK                       =  6; // Symbolic Link (unicode)
   var REG_MULTI_SZ                   =  7; // Multiple Unicode strings
   var REG_RESOURCE_LIST              =  8; // Resource list in the resource map
   var REG_FULL_RESOURCE_DESCRIPTOR   =  9; // Resource list in the hardware description
   var REG_RESOURCE_REQUIREMENTS_LIST = 10; //
   var REG_QWORD                      = 11; // 64-bit number

   var names = [], types = [], binvals = [], dates = [], ret;
   var binval;
   var MaxBinLength = 0;
   var MaxBinLengthName = "";
   
   subkeys = regObj.RegEnumKey( root, path );
   values  = regObj.RegEnumValues( root, path );
   
   for ( var i = 0; i < values.length; i++ )
   {
      names[ i ] = values[ i ].name;
      types[ i ] = values[ i ].type;
      if ( types[ i ] == REG_BINARY )
      {
         binvals[ binvals.length ] = names[ i ];
         binval = regObj.RegGetBinaryValue( root, path, names[ i ] );
         if ( binval.length > MaxBinLength )
         {
            MaxBinLength = binval.length;
            MaxBinLengthName = names[ i ];
         }
      }
      if ( types[ i ] == REG_QWORD )
      {
         qw  = regObj.RegGetQWORDValue( root, path, names[ i ] );
         if ( qw > 123000000000000000  // 1990.10.10 06:41:01
         &&   qw < 130907120609450000 )// 2015.10.30 24:55:21
         {                                      // 281474976710656
            Out.StdOut.WriteLine( "Date at " + path + " " + names[ i ] );
            Out.StdOut.WriteLine( qw + " " + regObj.RegDateToDate( qw ).toString() );
            dates[ dates.length ] = qw;
         }
      }  
   }
   
   obj            = {};
   obj.path       = path;
   obj.valuenames = names.join( "," );
   obj.valuetypes = types.join( "," );
   obj.subkeys    = subkeys.join( "," );
   obj.binvals    = binvals.join( "," );
   obj.dates      = dates.join( "," );
   obj.HasSubKeys = ( subkeys.length > 0 );
   obj.HasBinary  = ( binvals.length > 0 );
   if ( obj.HasBinary )
   {
      obj.MaxBinLength = MaxBinLength;
      obj.MaxBinLengthName = MaxBinLengthName;
   }
   objects[ objects.length ] = obj;  

   for ( var i = 0; i < subkeys.length; i++ )
   {
      ret     = DeepDive( root, path + "\\" + subkeys[ i ], objects );
      objects = ret.objects;
      for ( var j = 0; j < ret.subjeys; j++ )
      {
         subkeys[ subkeys.length ] = ret.subkeys[ j ];
      }
   }
   return { "subkeys": subkeys, "objects": objects };
}
function DeleteSubpath( root, head, tail )
{
   var rc, subkeys, ret;
   var HKCR = 0x80000000;// HKEY_CLASSES_ROOT
   var HKCU = 0x80000001;// HKEY_CURRENT_USER
   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var HKCC = 0x80000005;// HKEY_CURRENT_CONFIG
   var path = head + "\\" + tail;
   var cnt  = tail.split( "\\" ).length;
   for ( var i = 0; i < cnt; i++ )
   {
      rc = regObj.RegDeleteKey( root, path );
      PutMsg( rc, "RegDeleteKey", path ); 
      path = path.substr( 0, path.lastIndexOf( "\\" ) );
   }
}
function CopyKeyAndValues( SourceRoot, SourcePath, TargetRoot, TargetPath, key )
{
   var rc, vals, subkeys = [], value, name, type, valuesObj, val;
   var DiskIdPath, TimestampPath, tmp;
   
   var HKCR = 0x80000000;// HKEY_CLASSES_ROOT
   var HKCU = 0x80000001;// HKEY_CURRENT_USER
   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var HKCC = 0x80000005;// HKEY_CURRENT_CONFIG

   var REG_NONE                       =  0; // No value type
   var REG_SZ                         =  1; // Unicode nul terminated string
   var REG_EXPAND_SZ                  =  2; // Unicode nul terminated string
                                            // (with environment variable references)
   var REG_BINARY                     =  3; // Free form binary
   var REG_DWORD                      =  4; // 32-bit number
   var REG_DWORD_BIG_ENDIAN           =  5; // 32-bit number
   var REG_LINK                       =  6; // Symbolic Link (unicode)
   var REG_MULTI_SZ                   =  7; // Multiple Unicode strings
   var REG_RESOURCE_LIST              =  8; // Resource list in the resource map
   var REG_FULL_RESOURCE_DESCRIPTOR   =  9; // Resource list in the hardware description
   var REG_RESOURCE_REQUIREMENTS_LIST = 10; //
   var REG_QWORD                      = 11; // 64-bit number

   rc = regObj.RegCreateKey( TargetRoot, TargetPath, key );
   PutMsg( rc, "CreateKey", TargetPath, key ); 
   if ( rc )
   {
      return { "ErrCode": 2, "Subkeys": subkeys };
   }
   
   SourcePath += "\\" + key;
   TargetPath += "\\" + key;

   valuesObj = regObj.RegEnumValues( SourceRoot, SourcePath );

   if ( valuesObj && valuesObj.length )// if values exists
   {
      for ( var i = 0; i < valuesObj.length; i++ )
      {
         type = valuesObj[ i ].type;
         name = valuesObj[ i ].name;
         val  = null;
         switch( type )
         {
         case REG_NONE:       
            val = regObj.RegGetStringValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetStringValue( TargetRoot, TargetPath, name, "" ); 
            PutMsg( rc, "RegSetNONEValue", TargetPath, name ); 
            break;
         case REG_SZ:       
            val = regObj.RegGetStringValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetStringValue( TargetRoot, TargetPath, name, val ); 
            PutMsg( rc, "RegSetStringValue", TargetPath, name ); 
            break;
         case REG_EXPAND_SZ:
            val = regObj.RegGetExpandedStringValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetExpandedStringValue( TargetRoot, TargetPath, name, val );
            PutMsg( rc, "RegSetExpandedStringValue", TargetPath, name );
            break;
         case REG_MULTI_SZ: 
            val = regObj.RegGetMultiStringValue( SourceRoot, SourcePath, name, 1 ); 
            rc  = regObj.RegSetMultiStringValue( TargetRoot, TargetPath, name, val  ); 
            PutMsg( rc, "RegSetMultiStringValue", TargetPath, name );
            break;
         case REG_BINARY:   
            val = regObj.RegGetBinaryValue( SourceRoot, SourcePath, name, 1 ); 
            rc  = regObj.RegSetBinaryValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetBinaryValue", TargetPath, name );
            break;
         case REG_DWORD:    
            val = regObj.RegGetDWORDValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetDWORDValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetDWORDValue", TargetPath, name );
            break; 
         case REG_QWORD:    
            val = regObj.RegGetQWORDValue( SourceRoot, SourcePath, name );
            rc  = regObj.RegSetQWORDValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetQWORDValue", TargetPath, name );
            break;
         } // End-of-Switch
         if ( rc )
         {
            return { "ErrCode": 2, "Subkeys": subkeys };
         }
         rc  = regObj.RegDeleteValue( TargetRoot, TargetPath, name );
         PutMsg( rc, "RegDeleteValue", TargetPath, name );
      } // End-of-i-loop
      for ( var i = 0; i < valuesObj.length; i++ )
      {
         type = valuesObj[ i ].type;
         name = valuesObj[ i ].name;
         val  = null;
         switch( type )
         {
         case REG_SZ:       
            val = regObj.RegGetStringValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetStringValue( TargetRoot, TargetPath, name, val ); 
            PutMsg( rc, "RegSetStringValue", TargetPath, name ); 
            break;
         case REG_EXPAND_SZ:
            val = regObj.RegGetExpandedStringValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetExpandedStringValue( TargetRoot, TargetPath, name, val );
            PutMsg( rc, "RegSetExpandedStringValue", TargetPath, name );
            break;
         case REG_MULTI_SZ: 
            val = regObj.RegGetMultiStringValue( SourceRoot, SourcePath, name, 1 ); 
            rc  = regObj.RegSetMultiStringValue( TargetRoot, TargetPath, name, val  ); 
            PutMsg( rc, "RegSetMultiStringValue", TargetPath, name );
            break;
         case REG_BINARY:   
            val = regObj.RegGetBinaryValue( SourceRoot, SourcePath, name, 1 ); 
            rc  = regObj.RegSetBinaryValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetBinaryValue", TargetPath, name );
            break;
         case REG_DWORD:    
            val = regObj.RegGetDWORDValue( SourceRoot, SourcePath, name ); 
            rc  = regObj.RegSetDWORDValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetDWORDValue", TargetPath, name );
            break; 
         case REG_QWORD:    
            val = regObj.RegGetQWORDValue( SourceRoot, SourcePath, name );
            rc  = regObj.RegSetQWORDValue( TargetRoot, TargetPath, name, val  );
            PutMsg( rc, "RegSetQWORDValue", TargetPath, name );
            break;
         } // End-of-Switch
         if ( rc )
         {
            return { "ErrCode": 2, "Subkeys": subkeys };
         }
          
         if ( "Capabilities" == name )
         {
            DiskIdPath    = SourcePath + "\\Device Parameters\\Partmgr";
            TimestampPath = SourcePath + "\\Device Parameters\\Storport";
      
            rc = regObj.RegGetStringValue( HKLM, DiskIdPath, "DiskId" );
            
            if ( typeof( rc ) == "string" )
            {
               tmp = regObj.RegGetQWORDValue( HKLM, TimestampPath, "InitialTimestamp" );
               if ( tmp != null )
               {
                  Out.StdOut.WriteLine( "RegDateToDate: " + regObj( tmp ).toString() ); 
               }
            }
         }         
         
      } // End-of-i-loop
      rc  = regObj.RegDeleteAllValues( TargetRoot, TargetPath );
      PutMsg( rc, "RegDeleteAllValues", TargetPath );
   } // End-of-if
   
   subkeys = regObj.RegEnumKey( SourceRoot, SourcePath );
   return { "ErrCode": 0, "SubKeys": subkeys };
}
function CopyTree( SourceRoot, SourcePath, TargetRoot, TargetPath )
{
   Out.StdOut.WriteLine( "CopyTree SourcePath: " + SourcePath );
   var rc, subkeys, ret;
   var HKCR = 0x80000000;// HKEY_CLASSES_ROOT
   var HKCU = 0x80000001;// HKEY_CURRENT_USER
   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var HKCC = 0x80000005;// HKEY_CURRENT_CONFIG
   
   subkeys = regObj.RegEnumKey( SourceRoot, SourcePath );
   var sj = SourcePath; 
   var tj = TargetPath;
   var branches = [], retj, DiskIdPath, TimestampPath, tmp;

   for ( var i = 0; i < subkeys.length; i++ )
   {
      sj = SourcePath + "\\" + subkeys[ i ];
      tj = TargetPath + "\\" + subkeys[ i ];
      ret = CopyKeyAndValues( SourceRoot, SourcePath, TargetRoot, TargetPath, subkeys[ i ] );
      PutMsg( ret.ErrCode, "CopyKeyAndValues", sj, subkeys[ i ] );
      if ( ret.ErrCode ) continue;
      for ( var j = 0; j < ret.SubKeys.length; j++ )
      {
         retj = CopyKeyAndValues( SourceRoot, sj, TargetRoot, tj, ret.SubKeys[ j ] );
      }
      branches[ branches.length ] = tj;
      Out.StdOut.WriteLine( "*** " + tj );
      for ( j = 0; j < ret.SubKeys.length; j++ )
      {
         rc = regObj.RegDeleteKey( TargetRoot, tj + "\\" + ret.SubKeys[ j ] );
         PutMsg( rc, "RegDeleteKey", tj+"\\"+ret.SubKeys[ j ] );
      } 
      rc = regObj.RegDeleteKey( TargetRoot, TargetPath + "\\" + subkeys[ i ] );
      PutMsg( rc, "RegDeleteKey", TargetPath + "\\" + subkeys[ i ] );           
   }
   Out.StdOut.WriteLine( "*** " + branches.length + " branches built" );
   return branches;   
}
function TestcaseForCreatetSetMethods()
{
   var HKLM = 0x80000002; 
   var dirs = "Test1L2\\Test1L3\\Test1L4\\Test1L5," +
              "Test2L2\\Test2L3\\Test2L4," +
              "Test3L2\\Test3L3\\Test3L4\\Test3L5,Test3L6," +
              "Test4L2\\Test4L3";
   dirs = dirs.split( "," );
   var rc, tp, vbarr;
   for ( var i = 0; i < 1; i++ )//i < dirs.length; i++ )
   {
      rc = regObj.RegCreatePath( HKLM, "SOFTWARE", dirs[i] ); 
      PutMsg( rc, "RegCreatePath", "SOFTWARE\\" + dirs[i] );

      rc = regObj.RegSetDWORDValue( HKLM, "SOFTWARE\\" + dirs[i], "DWORD1", 1 );
      PutMsg( rc, "RegSetDWORDValue", "SOFTWARE\\" + dirs[i] );  
 
      rc = regObj.RegSetQWORDValue( HKLM, "SOFTWARE\\" + dirs[i], "QWORD1", 130843411733024957 );  
      PutMsg( rc, "RegSetQWORDValue", "SOFTWARE\\" + dirs[i] );  
        
      rc = regObj.RegSetStringValue( HKLM, "SOFTWARE\\" + dirs[i], "String1", "Life is good" );  
      PutMsg( rc, "RegSetStringValue", "SOFTWARE\\" + dirs[i] );   
      
      rc = regObj.RegSetExpandedStringValue( HKLM, "SOFTWARE\\" + dirs[i], "ExpandedString1", "%disk_devdesc%" ); 
      PutMsg( rc, "RegSetExpandedStringValue", "SOFTWARE\\" + dirs[i] ); 
 
      // DeviceDesc @disk.inf,%disk_devdesc%;Disk drive
      rc =  regObj.RegCreateKey( HKLM, "SOFTWARE\\Test1L2", "Test2L3" );
      PutMsg( rc, "RegCreateKey", "SOFTWARE\\Test1L2\\Test2L3" ); 
 
      rc =  regObj.RegCreateKey( HKLM, "SOFTWARE\\Test1L2", "Test3L3" );
      PutMsg( rc, "RegCreateKey", "SOFTWARE\\Test1L2\\Test3L3" ); 

      // 
      // Tricky way to get VBarray value: 4-th parameter was defined for the method
      // RegGetMultiStringValue. If present then VBArray is returned by this function
      // without conversion. Thus we have an opportunity to use it in RegSetMultiStringValue
      // and we use it twice in the code below. Thus we show that method RegSetMultiStringValue
      // runs fine provided key is VBArray. The same trick is used to verify RegSetBinaryValue,
      // it also runs fine provided VBArray is passed as a value.
      //
      tp = "SYSTEM\\CurrentControlSet\\Control\\SystemInformation";
      vbarr = regObj.RegGetMultiStringValue( HKLM, tp, "ComputerHardwareIds", true );
      rc = regObj.RegSetMultiStringValue( HKLM, "SOFTWARE\\Test1L2\\Test2L3", "ComputerHardwareIds", vbarr );
      PutMsg( rc, "RegSetMultiStringValue", "SOFTWARE\\Test1L2\\Test2L3 HardwareIds" );

      rc = regObj.RegSetMultiStringValue( HKLM, "SOFTWARE\\Test1L2\\Test3L3", "ComputerHardwareIds", vbarr );
      PutMsg( rc, "RegSetMultiStringValue", "SOFTWARE\\Test1L2\\Test3L3 HardwareIds" );
      
      tp = "SYSTEM\\CurrentControlSet\\Control\\PnP\\Pci\\CardList";
      vbarr = regObj.RegGetBinaryValue( HKLM, tp, "Ali", true );
      rc = regObj.RegSetBinaryValue( HKLM, "SOFTWARE\\Test1L2\\Test2L3", "Ali", vbarr );
      PutMsg( rc, "RegSetBinaryValue", "RegSetBinaryValue SOFTWARE\\Test1L2\\Test2L3", "Ali" );
      
      rc = regObj.RegSetBinaryValue( HKLM, "SOFTWARE\\Test1L2\\Test3L3", "Ali", vbarr );
      PutMsg( rc, "RegSetBinaryValue", "RegSetBinaryValue SOFTWARE\\Test1L2\\Test3L3", "Ali" );

      vbarr = regObj.RegGetBinaryValue( HKLM, tp, "Toshiba", true );
      rc = regObj.RegSetBinaryValue( HKLM, "SOFTWARE\\Test1L2\\Test2L3", "Toshiba", vbarr );
      PutMsg( rc, "RegSetBinaryValue", "RegSetBinaryValue SOFTWARE\\Test1L2\\Test2L3", "Toshiba" );
      
      rc = regObj.RegSetBinaryValue( HKLM, "SOFTWARE\\Test1L2\\Test3L3", "Toshiba", vbarr );
      PutMsg( rc, "RegSetBinaryValue", "RegSetBinaryValue SOFTWARE\\Test1L2\\Test3L3", "Toshiba" );
      
      rc = regObj.RegDeleteValue( HKLM, "SOFTWARE\\Test1L2\\Test2L3", "Ali" );
      PutMsg( rc, "RegDeleteValue", "SOFTWARE\\Test1L2\\Test2L3",  "Ali" );
      
      rc = regObj.RegDeleteAllValues( HKLM, "SOFTWARE\\Test1L2\\Test3L3" );
      PutMsg( rc, "RegDeleteAllValues", "SOFTWARE\\Test1L2\\Test3L3" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2\\Test2L3" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2\\Test2L3" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2\\Test3L3" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2\\Test3L3" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2\\Test1L3\\Test1L4\\Test1L5" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2\\Test1L3\\Test1L4\\Test1L5" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2\\Test1L3\\Test1L4" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2\\Test1L3\\Test1L4" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2\\Test1L3" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2\\Test1L3" );
      
      rc = regObj.RegDeleteKey( HKLM, "SOFTWARE\\Test1L2" );
      PutMsg( rc, "RegDeleteKey", "SOFTWARE\\Test1L2" );
   }
   Out.StdOut.WriteLine( "\n" );
   
   rc =  regObj.CreateKey( HKLM, "SOFTWARE\\TestStdRegProv" );
   var branches, tail;
   Out.StdOut.WriteLine( "RegCreateKey SOFTWARE\\TestStdRegProv" + " RC="+rc );
   var head = "SOFTWARE\\TestStdRegProv";
   var sbranches = [ 
      "SYSTEM\\DriverDatabase\\DeviceIds\\{36fc9e60-c465-11cf-8056-444553540000}",
      "SYSTEM\\CurrentControlSet\\Control\\hivelist",
      "SYSTEM\\CurrentControlSet\\Control\\SystemInformation",
      "SYSTEM\\CurrentControlSet\\Control\\PnP\\Pci",
      "SYSTEM\\CurrentControlSet\\Control\\Video",
      "SYSTEM\\CurrentControlSet\\Enum\\SD",
      "SYSTEM\\CurrentControlSet\\Enum\\SCSI", 
      "SYSTEM\\CurrentControlSet\\Enum\\STORAGE",
      "SYSTEM\\CurrentControlSet\\Enum\\USBSTOR",
      "HARDWARE\\DEVICEMAP\\Scsi",
      "HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\0\\DiskController\\0\\DiskPeripheral"
   ];
   
   if ( rc == 0 )
   {
      for ( var i = 0; i < sbranches.length; i++ )//sbranches.length
      {
         branches = CopyTree( HKLM, sbranches[ i ], HKLM, head );
         Out.StdOut.WriteLine( "CopyTree branches.length = "+branches.length );
         for ( var j = 0; j < branches.length; j++ )
         {
            tail = branches[ j ].substr( head.length + 1 );
            DeleteSubpath( HKLM, head, tail );
         }
      }

      rc = regObj.RegDeleteKey( HKLM, head );
      PutMsg( rc, "RegDeleteKey", head );
      return false;
   }               
   
   return false;  

}
</script>//<!-- TestCase-StdRegWrapperClassTest TrailingTag -->
</job>
<!----End-of-StdRegWrapperClassTest.wsf--------------------------------->
</package>
